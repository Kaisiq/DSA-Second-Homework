# Условие на задачата
След невероятния успех на кампанията по продажба на банани и швепс в магазините МразМаг<br>
фирмата се разраснала неимоверно. Толкова много, че се наложило да въведат много<br>
сложна йерархия на служители, по-малки мениджъри, по-големи мениджъри и шефове.

Разбира се главният изпълнителен директор останал един – Петър Петров (по прякор Успешния).<br>
За да успява да следи клоновата си мрежа и всички нейни служители, <br>
Успешният помолил своя екип разработчици да му напише програма, <br>
която да може да прочита от текст (string) описание на професионални взаимоотношения <br>
и след това да построява дърво, което да представя тези връзки (шеф-подчинен). <br>
Едно такова дърво описва взаимоотношенията в рамките на един клон на компанията <br>
(отдел, магазин и т.н.). Понеже преди да се захване с търговия на дребно, Успешния<br>
бил учил малко във ФМИ, той знаел, че когато всеки служител (освен него самия, разбира се)<br>
има точно един шеф, то построяване на такова дърво било не само възможно, но и лесно.

## Вход
Програмата ви ще трябва да може да зарежда входа си от **един или повече текстови файлове**.<br>
Всеки един такъв файл съдържа нула, един или повече редове, като всеки ред съдържа <br>
описанието на едно взаимоотношение ръководител-подчинен. Например редът `“Ivan-Georgi”` <br>
означава, че **Иван е пряк ръководител на Георги**.

Имената на хората не съдържат празни символи или тире и всяка такава двойка е на отделен ред.<br>
Редът, в който те са подредени при въвеждането не е строго определен, но трябва всеки<br>
с роля ръководител първо да се е появил с роля подчинен (освен главният изпълнителен <br>
директор, който на никого не е подчинен). Например не може във входа да се срещне ред <br>
`“Ivan-Georgi”`, ако преди това не е имало друг запис, в който да се укаже на кого е <br>
подчинен Иван.

Всеки човек се предполага да се среща точно един път в ролята на подчинен в записите. <br>
За улесняване на задачата предполагаме, че не може да има двама човека с еднакви имена,<br>
като отчитаме разликите между малки и главни букви. Тъй като предполагаме, че в корена<br>
на всяко едно такова дърво стои Успешния, за него не добавяме запис - той може да бъде<br>
използван директно, за да се укаже кои са преките му подчинени, например `“Uspeshnia - Ivan”`.<br>
Няма ограничение в дълбочината на дървото, което ще се построи.

## Операции
Освен да зареждате такива данни и да построявате съответните на йерархиите им дървета трябва да можете да извършвате различни операции с тях:<br>
На първо място трябва да проверите дали подадените ви данни са коректни и ако не са да сигнализирате за това;<br>
Да можете да проверите дали даден служител е част от дадена йерархия;<br>
За даден служител трябва да можете да кажете броя на преките му подчинени;<br>
За даден служител трябва да можете да кажете името на прекия му ръководител;<br>
За дадена йерархия трябва да можете да кажете броя на всички служители в нея;<br>
Трябва да намирате броя на всички ръководители, които са претоварени - имат повече от N подчинени (преки или не). N е параметър на операцията;<br>
Трябва да може да обединявате две дървета (представящи йерархии от два отдела). Това да става по следната схема:<br>
Ако служител се среща и в двете йерархии, то в обединението той също се среща като там преките му подчинени са всички негови преки подчинени от двете йерархи. Предполага се Успешният да е на върха и на двете места. Това правило се прилага рекурсивно надолу (за всички служители от върха надолу). Ако в двата отдела този служител има различни ръководители, то в обединението трябва да остане само една инстанция, закачена към по-високо стоящия в йерархията ръководител. Ако двата са на едно ниво (например преки подчинени на Успешния), то изберете този с лексикографски по-малкото име. Не се предполага за двама служители в едната йерархия единият да е подчинен на другия, а в другата - обратно;<br>
Ако даден служител се среща само в едната йерархия, той присъства в обединението, точно под инстанцията на ръководителя си (като негов пряк подчинен), заедно с всички свои подчинени от съответното дърво;<br>
Сливането не е възможно ако има ситуация, в която служител X е подчинен на Y в едната йерархия (пряко или не), а в другата е обратно. В такъв случай не трябва да създавате слятата йерархия.<br>
По подадена йерархия и име на служител трябва да уволните (премахнете) служителя, като всички негови подчинени стават съответно подчинени на ръководителя му. Разбира се, няма как да се уволни Успешния;<br>
По подадена йерархия, име на служител и име на ръководител трябва да назначите служителя като подчинен на този ръководител. Проверете дали служителят вече не работи с друг ръководител. Тогава преместете служителя на новата му позиция (преназначаване). Ако в този случай служителят е имал подчинени, то те остават под него в йерархията;<br>
Трябва да можете да записвате дърво в символен низ (string). Форматът е описан по-подробно в следващия раздел на документа;<br>
За една фирма трябва да можете да кажете от колко човека се състои най-дългата верига от отношения ръководител-подчинен;<br>
Трябва да може да смятате заплатата на даден служител, като тя се определя по следната формула: 500 * <брой преки подчинени> + 50 * <брой не преки подчинени>;<br>
Трябва да може да инкорпорирате една йерархия. Това става като за всеки екип (множество служители с общ пряк ръководител), който има поне двама служителя, се избере служителят с най-висока заплата и се направи шеф на този екип. Ако този служител има собствени подчинени, те остават в неговия екип. Ако има повече от един такъв служител, да се избере този с лексикографски най-малкото име. Инкорпорирането започва от най-ниските нива в йерархията. На фигурата по-долу е показана йерархия преди инкорпориране и съответно след. В първоначалната йерархия са подчертани със зелено екипите и с червено служителят, който ще бъде повишен.<br>

Трябва да може да модернизирате една фирма. Това става като за всеки ръководител на нечетно ниво спрямо Успешния, неговият екип се слее с екипа на по-висшия ръководител. Ръководителят се премахва. Модернизацията започва от най-ниските нива на йерархията.<br>
Представяне на дърво като символен низ.<br>

Всяко дърво от разглеждания тип може да се представи като редица от двойки от вид ръководител-подчинен. В редицата те трябва да са подредени по следния начин:<br>
Старшинство (от най-висшия към по-нисшите ръководители).<br>
Записите, в които има двама ръководители от едно ниво на йерархията, се подреждат лексикографски – най-напред по името на ръководителя, а когато то съвпада за два различни записа, по името на служителя.<br>
Всяка двойка ръководител-подчинен се представя като низ като конкатенираме техните имeнa със символа тире и завършва със символа за нов ред. Дървото представяме като конкатенация на всички такива двойки. Например за лявото дърво от фигурата по-горе, ще имаме следното представяне:<br>

`"Uspeshnia-Gosho\nUspeshnia-Misho\nUspeshnia-Slavi\nGosho-Dancho\nGosho-PeshonSlavi-Slav1\nSlavi-Slav2\nDancho-Boris\nDancho-Kamen\nPesho-Alex\nSlav1-Mecho\nMecho-Q12Adl\n"
`

Което, за по-лесно, даваме по-долу и така както би изглеждал след извеждане на екрана:

> Uspeshnia-Gosho<br>
Uspeshnia-Misho<br>
Uspeshnia-Slavi<br>
Gosho-Dancho<br>
Gosho-Pesho<br>
Slavi-Slav1<br>
Slavi-Slav2<br>
Dancho-Boris<br>
Dancho-Kamen<br>
Pesho-Alex<br>
Slav1-Mecho<br>
Mecho-Q12Adl<br>

## Операции
Програмата, която реализирате, трябва да има интерактивен конзолен потребителски интерфейс, в който да се поддържат всички гореизброени функционалности.  Ако нещо не е наред (грешен формат на данните, не е намерен посочен файл и др.) програмата ви трябва да продължи да работи коректно и трябва да изведете на екрана подходящо съобщение за потребителя.<br>
Командите, които трябва да обработвате (като минимум) са:<br>

help – извежда списък на поддържаните команди с кратка помощна информация за тях;

load име_на_обект име_на_файл – зарежда данни за йерархия от файл с подаденото име и създава дърво, асоциирано с име_на_обект. Това име трябва да се състои само от малки и главни латински букви, цифри и символ за подчертаване. След него всичко до края на реда е името на файла от който трябва да прочетете данните в описания по-горе формат. Ако името на файла липсва се предполага да прочетете данните от стандартния вход, до срещане на край на файл (ctrl+z/ctrl+d);

save име_на_обект име_на_файл – записва информацията за йерархията на посочения обект във файл с посоченото име. Ако името на файла е празно, информацията да се изведе на стандартния изход;

find име_на_обект име_на_служител – проверява дали в посочения обект съществува служител с посоченото име;

num_subordinates име_на_обект име_на_служител – извежда броя преки подчинени на дадения служител  в посочения обект;

manager име_на_обект име_на_служител – извежда името на ръководителя на дадения служител  в посочения обект;

num_employees име_на_обект – извежда броя служители в посочения обект;

overloaded име_на_обект – извежда броя служители в посочения обект, за които броят подчинени (преки или не) е по-голям от 20;

join име_на_обект_1 име_на_обект_2 име_на_обект_резултат – обединява двата подадени обекта в нов обект с име име_на_обект_резултат;

fire име_на_обект име_на_служител – премахва служителя от съответния обект;

hire име_на_обект име_на_служител име_на_ръководител – назначава служителя в съответния обект като подчинен на подадения ръководител;

salary име_на_обект име_на_служител – извежда заплатата на служителя;

incorporate име_на_обект – инкорпорира фирмата; операцията се прилага върху обекта име_на_обект;

modernize име_на_обект – модернизира фирмата; операцията се прилага върху обекта име_на_обект;

exit - прекратява изпълнението на програмата. За всички нови или променени след зареждането обекти попитайте потребителя дали иска да ги запази във файл.

## Примерно изпълнение на програмата


> load Lozenec<br>
Uspeshnia - Gosho<br>
Uspeshnia - Misho<br>
Gosho - Pesho<br>
Gosho - Dancho<br>
Pesho - Alex<br>
Dancho-Boris<br>
Dancho-Kamen<br>
Uspeshnia - Slavi<br>
Slavi - Slav1<br>
Slavi - Slav2<br>
Slav1-Mecho<br>
Mecho-Q12Adl<br>
^Z<br>
Lozenec loaded successfully!

> find Lozenec Alex<br>
Alex is employed in Lozenec.

> num_subordinates Lozenec Alex<br>
Alex has no subordinates.

> num_subordinates Lozenec Slavi<br>
Slavi has two subordinates.

> manager Lozenec Slav1<br>
The manager of Slav1 is Slavi.

> manager Lozenec Slav3<br>
There is no Slav3 in Lozenec.

> num_employees Lozenec<br>
There are 13 employees in Lozenec.

> num_employees Lozenec2<br>
Lozenec2 is an unknown office!

> overloaded Lozenec<br>
No overloaded employees in Lozenec.

> load Lozenec_new<br>
Uspeshnia - MishoPetrov<br>
MishoPetrov - Misho<br>
MishoPetrov - Slav<br>
^Z<br>
Lozenec_new loaded successfully!

> join Lozenec Lozenec_new LozBig<br>
LozBig created.

> save LozBig LozBig.data<br>
LozBig saved.

> manager LozBig Misho<br>
The manager of Misho is Uspeshnia.

>num_subordinates LozBig MishoPetrov<br>
MishoPetrov has one subordinates.

> fire LozBig MishoPetrov<br>
MishoPetrov was fired.

> num_subordinates LozBig Uspeshnia<br>
Uspeshnia has four subordinates.

> hire Lozenec MishoPetrov Misho<br>
MishoPetrov was hired.

> salary Lozenec Gosho<br>
The salary is 1150 BGN.

> hire Lozenec_new Mitko Uspeshnia<br>
Mitko was hired.

> hire Lozenec_new MishoPetrov Mitko<br>
MishoPetrov was hired.

> incorporate Lozenec_new<br>
Lozenec_new incorporated.

> save Lozenec_new<br>
Uspeshnia-MishoPetrov<br>
Uspeshnia-Mitko<br>
MishoPetrov-Misho<br>
MishoPetrov-Slav<br>

> hire Lozenec_new Ivan Misho<br>
Ivan was hired.

> hire Lozenec_new Stojan Ivan<br>
Stojan was hired.

> modernize Lozenec_new<br>
Lozenec_new modernized.

> save Lozenec_new<br>
Uspeshnia-Misho<br>
Uspeshnia-Slav<br>
Misho-Stojan

> save Lozenec_new loz.data<br>
Lozenec_new saved.

> exit<br>
Lozenec is modified, but not saved.<br>
Enter file name to save it:<br>
> lozenec.data<br>
Lozenec saved.<br>
Goodbye!


## Тестове

Тестове за задачата ще намерите в хранилището на следния адрес https://github.com/semerdzhiev/sdp-2021-22/tree/main/tests/2. Вашето решение трябва като минимум да минава тези тестове. Ако решението ви минава всички тестове това не означава автоматично получаване на пълен брой точки. Тестовете проверяват няколко конкретни случая и не са изчерпателни. Препоръчваме да добавите свои такива, които обхващат повече случаи.
За да може тестовете да проверяват коректността на вашето решение трябва да спазите няколко условия при реализация на кода си.

В interface.h ще намерите класа Hierarchy, който описва интерфейса, който вашето решение трябва да спазва за да може да бъде тествано от автоматичните тестове. Трябва да имплементирате всички изброени методи в реализация на този клас.

В tests.cpp ще намерите всички тестове, които вашето решение трябва да минава успешно. Тестовете трябва да минават без промяна на кода в този файл.
Ако смятате че някой тест противоречи на условието, пишете в дискорд канала и тагнете някой от екипа.

### ВАЖНО: Не забравяйте, че решението на задачата трябва да може да чете данни от клавиатурата и да пише резултата обратно в конзолата. Същото това решение трябва и да може да бъде тествано с автоматичните тестове. Това означава че трябва да има 2 под проекта (project във Visual Studio) - единият да пуска тестовете, а другият да имплементира вход/изход от потребител.

При реализацията е разрешено да използвате само класовете string, vector, list, <br>
forward_list, stack и queue от стандартната библиотека. Всички останали структури <br>
от данни или алгоритми, които са ви необходими при решаването на задачата трябва да<br>
реализирате сами.


